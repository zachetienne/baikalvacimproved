
# This schedule.ccl file was automatically generated by NRPy+.
#   You are advised against modifying it directly; instead
#   modify the Python code that generates it.

# First allocate storage for one timelevel of ADMBase gridfunctions, which is the
#    bare minimum needed by NRPy+. If another thorn (e.g., ADMBase itself) requests
#    more timelevels of storage, Cactus automatically allocates the maximum requested.
STORAGE: ADMBase::metric[1], ADMBase::curv[1], ADMBase::lapse[1], ADMBase::shift[1]

# Next allocate storage for all 3 gridfunction groups used in BaikalVacuum
STORAGE: evol_variables[3]     # Evolution variables
STORAGE: evol_variables_rhs[1] # Variables storing right-hand-sides
STORAGE: aux_variables[3]      # Diagnostics variables
STORAGE: auxevol_variables[1]  # Single-timelevel storage of variables needed for evolutions.

# The following scheduler is based on Lean/LeanBSSNMoL/schedule.ccl

schedule Banner_BaikalVacuum at STARTUP
{
  LANG: C
  OPTIONS: meta
} "Output ASCII art banner"

schedule RegisterSlicing_BaikalVacuum at STARTUP after Banner_BaikalVacuum
{
  LANG: C
  OPTIONS: meta
} "Register 3+1 slicing condition"

schedule Symmetry_registration_oldCartGrid3D_BaikalVacuum at BASEGRID
{
  LANG: C
  OPTIONS: Global
} "Register symmetries, the CartGrid3D way."

schedule zero_rhss_BaikalVacuum at BASEGRID after Symmetry_registration_oldCartGrid3D_BaikalVacuum
{
  LANG: C
} "Idea from Lean: set all rhs functions to zero to prevent spurious nans"

schedule ADM_to_BSSN_BaikalVacuum at CCTK_INITIAL after ADMBase_PostInitial
{
  LANG: C
  OPTIONS: Local
  SYNC: evol_variables
} "Convert initial data into BSSN variables"

schedule GROUP ApplyBCs as BaikalVacuum_ApplyBCs at CCTK_INITIAL after ADM_to_BSSN_BaikalVacuum
{
} "Apply boundary conditions"


# MoL: registration

schedule MoL_registration_BaikalVacuum in MoL_Register
{
  LANG: C
  OPTIONS: META
} "Register variables for MoL"


# MoL: compute RHSs, etc

if(FD_order == 4) {
  schedule Ricci_eval_BaikalVacuum_order_4 in MoL_CalcRHS as BaikalVacuum_Ricci before BaikalVacuum_RHS
  {
    LANG: C
  } "MoL: Compute Ricci tensor, needed for BSSN RHSs, at finite-differencing order: 4"

  schedule rhs_eval_BaikalVacuum_order_4 in MoL_CalcRHS as BaikalVacuum_RHS after BaikalVacuum_Ricci
  {
    LANG: C
  } "MoL: Evaluate BSSN RHSs, at finite-differencing order: 4"
}
if(FD_order == 6) {
  schedule Ricci_eval_BaikalVacuum_order_6 in MoL_CalcRHS as BaikalVacuum_Ricci before BaikalVacuum_RHS
  {
    LANG: C
  } "MoL: Compute Ricci tensor, needed for BSSN RHSs, at finite-differencing order: 6"

  schedule rhs_eval_BaikalVacuum_order_6 in MoL_CalcRHS as BaikalVacuum_RHS after BaikalVacuum_Ricci
  {
    LANG: C
  } "MoL: Evaluate BSSN RHSs, at finite-differencing order: 6"
}
if(FD_order == 8) {
  schedule Ricci_eval_BaikalVacuum_order_8 in MoL_CalcRHS as BaikalVacuum_Ricci before BaikalVacuum_RHS
  {
    LANG: C
  } "MoL: Compute Ricci tensor, needed for BSSN RHSs, at finite-differencing order: 8"

  schedule rhs_eval_BaikalVacuum_order_8 in MoL_CalcRHS as BaikalVacuum_RHS after BaikalVacuum_Ricci
  {
    LANG: C
  } "MoL: Evaluate BSSN RHSs, at finite-differencing order: 8"
}
schedule specify_NewRad_BoundaryConditions_parameters_BaikalVacuum in MoL_CalcRHS after BaikalVacuum_RHS
{
  LANG: C
} "NewRad boundary conditions, scheduled right after RHS eval."

schedule floor_the_lapse_BaikalVacuum in MoL_PostStep before enforce_detgammahat_constraint_BaikalVacuum before BC_Update
{
  LANG: C
} "Set lapse = max(lapse_floor, lapse)"

schedule enforce_detgammahat_constraint_BaikalVacuum in MoL_PostStep before BC_Update
{
  LANG: C
} "Enforce detgammabar = detgammahat (= 1 in Cartesian)"

schedule specify_BoundaryConditions_evolved_gfs_BaikalVacuum in MoL_PostStep
{
  LANG: C
  OPTIONS: LEVEL
  SYNC: evol_variables
} "Apply boundary conditions and perform AMR+interprocessor synchronization"

schedule GROUP ApplyBCs as BaikalVacuum_ApplyBCs in MoL_PostStep after specify_BoundaryConditions_evolved_gfs_BaikalVacuum
{
} "Group for applying boundary conditions"


# Next update ADM quantities

schedule BSSN_to_ADM_BaikalVacuum in MoL_PostStep after BaikalVacuum_ApplyBCs before ADMBase_SetADMVars
{
  LANG: C
  OPTIONS: Local
} "Perform BSSN-to-ADM conversion. Useful for diagnostics."

# Compute Hamiltonian & momentum constraints

if(FD_order == 4) {
  schedule BSSN_constraints_BaikalVacuum_order_4 as BaikalVacuum_BSSN_constraints in MoL_PseudoEvolution
  {
    LANG: C
    OPTIONS: Local
  } "Compute BSSN (Hamiltonian and momentum) constraints, at finite-differencing order: 4"
}

if(FD_order == 6) {
  schedule BSSN_constraints_BaikalVacuum_order_6 as BaikalVacuum_BSSN_constraints in MoL_PseudoEvolution
  {
    LANG: C
    OPTIONS: Local
  } "Compute BSSN (Hamiltonian and momentum) constraints, at finite-differencing order: 6"
}

if(FD_order == 8) {
  schedule BSSN_constraints_BaikalVacuum_order_8 as BaikalVacuum_BSSN_constraints in MoL_PseudoEvolution
  {
    LANG: C
    OPTIONS: Local
  } "Compute BSSN (Hamiltonian and momentum) constraints, at finite-differencing order: 8"
}

schedule specify_BoundaryConditions_aux_gfs_BaikalVacuum in MoL_PseudoEvolution after BaikalVacuum_BSSN_constraints
{
  LANG: C
  OPTIONS: LEVEL
  SYNC: aux_variables
} "Enforce symmetry BCs in constraint computation"


schedule GROUP ApplyBCs as BaikalVacuum_auxgfs_ApplyBCs in MoL_PseudoEvolution after specify_BoundaryConditions_aux_gfs_BaikalVacuum
{
} "Apply boundary conditions"
